import pandas as pd 
import numpy as np
from heapdict import heapdict
from heapq import heappush, heappop, heapify

def heuristic_algorithm(fullpath):
    # job structure 
    
    # see https://github.com/DanielStutzbach/heapdict
    # or directly !pip install HeapDict
    class Job:
        '''structure for 1 job '''
        def __init__(self, row):
            '''input := df.iloc[idx, :]'''
            self.id = row['Job ID']
            self.due = row['Due Time']
            self.next_op = 0 # True as complete, False as not yet processed
            self.stage_pt = [row['Stage-1 Processing Time'], row['Stage-2 Processing Time']]
            mfor1 = list(map(int, row['Stage-1 Machines'].split(',')))
            if row['Stage-2 Machines'] is not np.nan:
                mfor2 = list(map(int, row['Stage-2 Machines'].split(',')))
            else: mfor2 = [] 
            self.stage_mach = [mfor1, mfor2]
            self.assign_mach = [None for _ in range(2)]
            self.start_time = [-1 for _ in range(2)]
            self.end_time = [-1 for _ in range(2)]

    class Jobs:
        '''structure for multiple jobs' management'''
        def __init__(self, n):
            self.completion_times = np.zeros(n)
            self.tardiness = np.zeros(n)
            self.is_completed = np.full(n, False)
            self.residual_times = np.zeros(n)
            self.jobs = []

        def get_RRDD(self):
            if getattr(self, 'RRDD', None) is None:
                self.RRDD = self.due_dates - np.min(self.due_dates)
            return self.RRDD # static

        def get_LST(self):
            '''latest start time'''
            self.LST = self.due_dates - self.residual_times
            return self.LST

        def add_jobs(self, data):
            self.due_dates = data['Due Time'].to_numpy()
            for i in range(len(data)):
                row = data.iloc[i, :]
                jobi = Job(row)
                self.residual_times[i] = sum(jobi.stage_pt)
                self.jobs.append(jobi)


        def assign(self, job_name, mach, st):
            '''job_name = (2, 0) means job 3 and op 1
            note that job and op is 0-indexed as well as machines
            op
            '''

            i = 0 
            jobidx, op = job_name 
            job = self.jobs[jobidx]
            J.completion_times[jobidx] = st + job.stage_pt[op]
            J.residual_times[jobidx] -= job.stage_pt[op]
            job.assign_mach[op] = mach
            job.start_time[op] = st
            job.end_time[op] = J.completion_times[jobidx]
            job.next_op = op+1
            if op == 1:
                self.is_completed[jobidx] = True
        def __repr__(self):
            return f'\
              * Job id: {self.id}\n\
              * Due time:{self.due}\n\
              stage 1: {self.assign_mach[0]}\n\
                       {self.stage_pt[0]}, {self.stage_mach[0]}\n\
              stage 2: {self.assign_mach[1]}\n\
                       {self.stage_pt[1]}, {self.stage_mach[1]}'
        __str__ = __repr__

    class Machines:
        def __init__(self, df):
            '''pass the stage1, stage2 machine lists'''
            mfor1 = df['Stage-1 Machines'].values.tolist()
            mfor2 = df['Stage-2 Machines'].values.tolist()
            mfor1 = [list(map(int, x.split(','))) for x in mfor1]
            mfor2 = [list(map(int, x.split(','))) for x in mfor2 if x is not np.nan]
            mfor1 = sum(mfor1, [])
            mfor2 = sum(mfor2, [])
            self.number = max(max(mfor1), max(mfor2))
            self.versatile = [mfor1.count(i+1) + mfor2.count(i+1) for i in range(self.number)]
            self.schedule = [[] for _ in range(self.number)]
            self.span = [[] for _ in range(self.number)]
            self.fintime = [0 for _ in range(self.number)]

        def _schedule(self, mach, job_name, st, proc_time):
            '''mach is 0-indexed'''
            display_name = tuple([x+1 for x in job_name])
            self.schedule[mach].append(f'{display_name} {proc_time:.2f}') 
            self.span[mach].append(proc_time)
            self.fintime[mach] = st + proc_time

        def add_idle(self, mach, idle_time):
            self.schedule[mach].append(f'idle {idle_time:.2f}') 
            self.span[mach].append(idle_time)
            self.fintime[mach] += idle_time

    instances = []
    instances.append(pd.read_csv(fullpath))

    df = instances[0]
    M = Machines(df)
    J = Jobs(len(df))
    J.add_jobs(df)
    # print(J.residual_times)
    # print(J.get_LST())

    def make_Q(J):
        GAP = 0.1

        Job_keys = []
        for job_index in range(len(J.jobs)):
            op1_pt, op2_pt = J.jobs[job_index].stage_pt
            # 我覺得 due_dates 幾乎等於 total proc time的反而可以放後面(不太可能來得及，乾脆果斷放棄)
            LST = J.get_LST()
            if LST[job_index] <= GAP: # avoid division by zero error
                lst_ratios = [0, 0]
            else:
                lst_ratios = [op1_pt / J.LST[job_index], op2_pt / J.LST[job_index]]
            # preserve precedence:
            lst_ratios[0] = max(lst_ratios)
            # NOTE: min queue extracts by minimum value, so add a negative sign here
            # (lst_ratio, job_index, job_op)
            Job_keys.append((-lst_ratios[0], job_index, 0))
            Job_keys.append((-lst_ratios[1], job_index, 1))
        Q_0 = Job_keys[:]
        heapify(Q_0) 
        return Q_0

    def heuristic(J, M): 
        # best_makepsan = sum(job_processing_time) for all jobs / |M|
        TOLRATIO = 0.3
        best_makespan = sum(job.stage_pt[0]+job.stage_pt[1] for job in J.jobs)/M.number
        tolerance = best_makespan * TOLRATIO  # tolerance for idle time
        # tolerance is a hyper-parameter; if idle > tolerance, do not schedule the curr op in the current epoch. 
        # step 1. compute lst ratio for every operation 
        # step 2. make priority queue 
        Q = make_Q(J)
        fails = [0 for _ in range(len(J.jobs))]
        # step 6. check if all jobs are completed 
        epoch = 0
        while not np.all(J.is_completed):
            epoch += 1

            PERMIT = True
            # step 3. extract_min() to get the job with minimal LST and its other attributes
            _, curr_job_index, curr_op = heappop(Q)
            curr_job = J.jobs[curr_job_index]
            op_proc_time = curr_job.stage_pt[curr_op]
            job_name = (curr_job_index, curr_op)

            avail_machines_idx = [x-1 for x in curr_job.stage_mach[curr_op]]
            # if curr_job has no second operation 
            if op_proc_time <= 0: 
                J.assign(job_name = job_name, 
                        mach = -1,
                        st = curr_job.end_time[curr_op-1]) 
                # note that it's only possible for second operation to have proc time = 0
                # so this doesn't trigger index error
                continue 
            # step 4. calculate the best machine
            curr_machine = min(avail_machines_idx, key = lambda x: (M.fintime[x], M.versatile[x], x))

            # ARE THERE REASONS TO POSTPONE THE CURR OP?
            if J.completion_times[curr_job_index] + op_proc_time > J.due_dates[curr_job_index] and fails[curr_job_index] < 2:
                curr_new_value = float('inf')
                PERMIT = False

            # ARE THERE REASONS TO POSTPONE THE CURR OP?
            elif M.fintime[curr_machine] < J.completion_times[curr_job_index]:
                idle = J.completion_times[curr_job_index] - M.fintime[curr_machine]
                if idle > tolerance and curr_op == 1 and fails[curr_job_index] < 2:
                    PERMIT = False
                    if Q:
                        curr_new_value = Q[0][0] + 1
                    else:
                        curr_new_value = 0 # the last one 
                else:
                    M.add_idle( 
                    mach = curr_machine, 
                    idle_time = idle)

            if PERMIT:
                J.assign(job_name = job_name, 
                    mach = curr_machine, 
                     st = M.fintime[curr_machine]
                    ) 
                M._schedule(job_name = job_name, 
                   mach = curr_machine, 
                    proc_time = op_proc_time,
                   st = M.fintime[curr_machine])
                curr_new_value = J.get_LST()[curr_job_index]
            else: 
                fails[curr_job_index] += 1
            # print(f'{epoch} Fails Count:', fails)
            # update the LST value and push it back to Q if the job has its second operation that hasn't been done
            if not PERMIT:
                heappush(Q, (curr_new_value, curr_job_index, curr_op))
                # it maintains the heap invariant, no need to heapify

    Results = []
    data = instances[0]
    heuristic(J = J,M = M)
    Tardy_jobs = list(np.where(J.completion_times > J.due_dates)[0])
    Tardy_jobs = [x+1 for x in Tardy_jobs]
    Makespan = max(M.fintime)
    Results.append({'J':J, 'M':M})

    def make_results(J):
        '''pass in the resulted J'''
        n = len(J.jobs)
        machine, completion_time = [], []
        for i in range(n):
            op1_mach_id = J.jobs[i].assign_mach[0]+1
            op2_mach_id = J.jobs[i].assign_mach[1]+1
            op1_c_time = round(J.jobs[i].end_time[0], 3)
            op2_c_time = round(J.jobs[i].end_time[1], 3)
            machine.append([op1_mach_id, op2_mach_id])
            completion_time.append([op1_c_time, op2_c_time])
        assert len(machine) == len(completion_time) == n
        return machine, completion_time
    result = make_results(Results[0]['J'])
    return(result)
